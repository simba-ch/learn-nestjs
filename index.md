# 请求执行顺序

client side ---> middleware ---> guard ---> interceptor ---> pipe ---> route handle ---> middleware ---> interceptor ---> client side

# 纠正

# 补强：

管道概念

测试一下各装饰器的执行顺序

测试 use 的执行顺序

---

# 概述

## 控制器

控制器负责处理传入的**请求**和向客户端返回**响应**。

## 提供者

Nest 有一个内置的控制反转（"IoC"）容器，可以解决 providers 之间的关系。@Injectable() 装饰器只是冰山一角, 并不是定义 providers 的唯一方法。相反，您可以使用普通值、类、异步或同步工厂。

### 基于属性的注入**_(不是很懂)_**

如果顶级类依赖于一个或多个 providers，那么通过从构造函数中调用子类中的 super() 来传递它们就会非常烦人了。因此，为了避免出现这种情况，可以在属性上使用 @Inject() 装饰器。

## 模块

### 模块的引用（依赖注入）

## 中间件

1. 中间件运行在路由控制函数之前
2. 修改 request 和 reponse 对象
3. 挂起请求，运行下一个中间件，结束请求

### 类中间件

### 函数中间件

## 异常过滤器

## 管道

管道是具有`@Injectable`装饰器的类，管道应实现`PipeTransform`接口。

- **转换**：将输入数据转换为所需的数据输出
- **验证**：对输入数据进行验证，如果验证成功继续传递，验证失败则抛出异常
  它们将在验证路由参数，查询字符串参数，和请求体正文的情景中工作。

在路由处理函数上对处理函数中的每一个参数使用
当使用路由管道的时候，路由处理函数的每一个参数都会调用管道
实体类 可以用 `implements` 实现`type`，结合 prisma 的类型实现转换和验证

场景一：根据 id 从数据库查找用户实体返回

```ts
@Get(':id')
findOne(@Param('id', UserByIdPipe) userEntity: UserEntity) {
  return userEntity;
}
```

## 守卫

守卫是一个使用`@Injectable`装饰器的类。守卫应该实现`CanActivate`接口。
守卫在中间件之后，在拦截器和管道之前
**授权**：它们根据运行时出现的某些条件（例如权限，角色，访问控制列表等）来确定给定的请求是否由路由处理程序处理。这通常称为授权。

**_全局守卫，排除特定路由？_**

## 拦截器

拦截器是使用`@Injectable()`装饰器注解的类。拦截器应该实现`NestInterceptor`接口。

- 在函数执行前后绑定额外的逻辑
- 转换从函数返回的结果
- 转换从函数抛出的异常
- 扩展基本函数行为
- 根据所选条件完全重写函数（例如：缓存目的）

## 自定义装饰器

### 参数装饰器

更改 request response 的属性

### 装饰器聚合

执行顺序？

# 基本原理

## 循环依赖

## 模块参考

## 懒加载模块

## 应用上下文

- reflect
- SetMetadata

# 技术

## HTTP模块

# 安全

## 认证

## 权限

验证权限
显示（前端路由生成）
增删改查

用户：
基于角色
<del>一个路由可能会改变</del>

基于权限
<del>一个添加权限不应该访问所有的添加路由</del>
一个类有多个对应多个权限（增删改查），
一个路由对应一个类的一个权限（应该是这样）

路由问题：
<del>一个路由可访问的权限是可变的，比如角色可变，权限可变</del>
路由是不可变的，可变的是用户，用户的角色，权限等

数据库建立一个 permission 表去对应路由和权限
