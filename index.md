# 执行顺序


# 纠正



# 补强：

管道概念

测试一下各装饰器的执行顺序

测试 use 的执行顺序

## 模块的引用（依赖注入）

## 管道

实体类 `implements` type

当使用路由管道的时候，路由处理函数的每一个参数都会调用管道


## 守卫

全局守卫，排除特定路由？

## 拦截器

拦截器是使用`@Injectable()`装饰器注解的类。拦截器应该实现`NestInterceptor`接口。

- 在函数执行前后绑定额外的逻辑
- 转换从函数返回的结果
- 转换从函数抛出的异常
- 扩展基本函数行为
- 根据所选条件完全重写函数（例如：缓存目的）

## 自定义装饰器

### 装饰器聚合

执行顺序？

# 基本原理

# 安全

## 认证

## 权限

验证权限
显示（前端路由生成）
增删改查

用户：
基于角色
<del>一个路由可能会改变</del>

基于权限
<del>一个添加权限不应该访问所有的添加路由</del>
一个类有多个对应多个权限（增删改查），
一个路由对应一个类的一个权限（应该是这样）

路由问题：
<del>一个路由可访问的权限是可变的，比如角色可变，权限可变</del>
路由是不可变的，可变的是用户，用户的角色，权限等

数据库建立一个 permission 表去对应路由和权限
